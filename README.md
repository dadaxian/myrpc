# 服务端实现
## 主要方法
服务端的调用实现
首先服务端要注册通过 **_SocketRpcServer_** 执行 注册和 socket的监听
1. 关于注册
注册通过**_ServiceProvider_** （单例）来实现
   * 先讲 服务的properties序列化结果，要调用的方法所属类的实例，放入我们的map中
   * 调用Curator实现的zookeeper的客户端实现zookeeper的服务注册。
    
2. 关于监听
监听通过tcp/udp层面的socket来监听（while死循环），启动前执行钩子函数清除所有线程池
   * 一旦监听到，就新建一个自己创建的自定义的Runnable线程，传入socket，并在线程中传入RpcRequestHandler（单例）
    * 在实现的run（）中： 在RpcRequestHandler中，使用反射完成给定对象和方法/参数对方法的调用。

## 注意点
1. 需要注意的是 ，这里使用了单例工厂的写法，而且很多地方写的单例不安全。
2. 统一的参数没写好，比如socket本地暴露的接口定义不规范
3. 对多线程的处理，是值得借鉴的
4. 对扩展类的处理，那边看不懂

# 客户端实现
主要是通过写服务发现，到zookeeper上找服务名<组名，版本号，方法名>对应的服务地址<ip,port>,
然后通过动态代理接口类，实现在调用接口后远程调用（socket/netty）来返回数据;
1. 关于服务发现
发现是通过发现**_ServiceRecovery_**来实现
   * 首先根据调用的类的类名，组名 ，版本号 生成zookeeper的键值，
   *  然后获取对应的子节点（一堆socket三元组），通过一致性hash算法或者随机算法，选取一个作为目标地址
2. 关于远程调用，使用**_RpcRequestTransport_**接口对应的实现类（socket/netty，取决于服务端的监听方式）来发送request，并返回

## 注意点
1. 在服务发现时-> 选取服务-> 负载均衡—> 一致性hash
2. 调用服务时，通过动态代理服务接口生成代理类实现调用
3. 需要注意序列化方式！